---
title: "Lista 2"
author: "César Macieira"
date: "16/10/2019"
output: html_document
---
```{r,include=F,message=FALSE}
if(!require(distances)){ install.packages("distances"); require(distances)}
```
# Exercício 1
```{r}

rm(list=ls(all=T))
Hxy <- function(x,y){
  -(-(x*sin(20*y)+y*sin(20*x))^2*cosh(sin(10*x)*x)-(x*cos(10*y)-y*sin(10*x))^2*cosh(cos(20*y)*y))
}
simulacoes <- 10000
u <- runif(simulacoes)
x = y = array(0,c(simulacoes,1))
r <- 0.5
for(i in 2:simulacoes){
  test1 <- runif(1, min=max(x[i-1]-r,-1.1),max=min(x[i-1]+r,1.1));
  test2 <- runif(1, min=max(y[i-1]-r,-1.1),max=min(y[i-1]+r,1.1));
  delta <- Hxy(test1,test2)-Hxy(x[i-1],y[i-1]);
  rho <- min(exp(delta*log(i)/1),1);
  x[i] <- test1*(u[i]<rho)+x[i-1]*(u[i]>rho)
  y[i] <- test2*(u[i]<rho)+y[i-1]*(u[i]>rho)
}
x[simulacoes] #Valor da coordenada x
y[simulacoes] #Valor da coordenada y
-Hxy(x[simulacoes],y[simulacoes]) #Mínimo encontrado
```

# Exercício 2
```{r}
rm(list=ls(all=T))
n=100 # número de cidade
L=10 # comprimento do lado da região que abrange as cidades
x=L*runif(n) # coordenadas x das cidades
y=L*runif(n) # coordenadas y das cidades
caminho=seq(1:n) # caminhos possíveis
plot(x, y, xlim = c(0,L), ylim = c(0,L),type = "b", xlab = "Coordenada X",
     ylab = "Coordenada Y", main = "Mapa de distribuição das cidades")

distancia=function(caminho){
  d=0;
  k=length(caminho)
  xx=x[caminho]; 
  yy=y[caminho]
  d=d+sum(sqrt((xx[1:(k-1)]-xx[2:k])^2+(xx[1:(k-1)]-xx[2:k])^2))
  d;
}

pair=sample.int(n,2);
minimocidades=min(pair)
maximocidades=max(pair)
novarota=caminho
novarota[minimocidades:maximocidades]=rev(caminho[minimocidades:maximocidades])

tmin=0.01 # Temperatura admissível
alpha=0.999 # Coeficiente multiplicativo para o algoritmo ser mais rápido T[i+1]=alpha*T[i]
T=tini=500 # Temperatura inicial
E=distancia(caminho)
while(T >= tmin){
  pair=sample.int(n,2)
  minimocidades=min(pair)
  maximocidades=max(pair)
  novarota=caminho
  novarota[minimocidades:maximocidades]=rev(caminho[minimocidades:maximocidades])
  Enew=distancia(novarota)
  if(T*log(runif(1)) < E-Enew){
    E=Enew
    caminho=novarota
  }
  T=T*alpha
}
plot(x[caminho],y[caminho],type="b",xlab = "Coordenada X",
     ylab = "Coordenada Y", main = "Melhor caminho")
distancia(caminho) # distância mínima
```

# Exercício 3
<p>Para um número baixo de simulações, a convergência não é adequada.</p>
```{r}
cidades <- matrix(runif(200, min = 0, max = 100), ncol = 2)
matrizdistancias <- distances::distances(cidades) #Matriz de distancias

#Gerando caminho inicial
x_zero <- sample(1:100, size = 100, replace = FALSE)
x_zero[101] <- x_zero[1] 

#Funcao que cria um novo caminho trocando dois lugares de posição
novo_caminho_function <- function(caminho){
  tam <- length(caminho)
  c <- sample(2:(tam-1), size = 2, replace = FALSE)
  c.aux <- c(caminho[c[1]], caminho[c[2]])
  caminho[c[1]] <- c.aux[2]
  caminho[c[2]] <- c.aux[1]
  return(caminho)
}

#Funcao que calcula a distancia de um caminho
dist_caminho <- function(caminho, matriz_distancia){
  tam <- length(caminho)
  distancia <- 0
  for(i in 2:tam)
    distancia <- distancia + matriz_distancia[caminho[i-1],caminho[i]]
  return(distancia)
}

#Simulated Tempering
t_function <- function(t){
  return((t+1)^2)
}

trans_prob <- function(i){
  p <- sample(c("a","b","c"), size = 1, prob = c(0.4, 0.4, 0.2))
  if(i == 100 && (p == "b"))
    return(i)
  if(i == 100 && !(p == "b"))
    return(i - 1)
  if(i != 100 && (p == "a"))
    return(i + 1)
  if(i != 100 && (p == "b"))
    return(i)
  if(i != 100 && (p == "c"))
    return(i - 1)
}
NSim <- 100
caminho_aux <- rep(0,101)
dist_caminho_aux <- 0
p_t <- rep(0,NSim)
dist_caminhos <- rep(0,NSim)
i <- NSim
while(i >= 1){
  dist_x_zero <- dist_caminho(x_zero, matrizdistancias)
  caminho_aux <- novo_caminho_function(caminho = x_zero)
  dist_caminho_aux <- dist_caminho(caminho = caminho_aux, matriz_distancia = matrizdistancias)
  if(dist_caminho_aux < dist_x_zero){
    x_zero <- caminho_aux
    i <- i - 1
  }else{
    j <- trans_prob(i)
    if(j != i){
      p_trans <- min(1, exp(-dist_caminho_aux*((1/t_function(j))- (1/(t_function(i))))))
      if(rbinom(1,1,p_trans) == 1){
        i <- j
        x_zero <- caminho_aux
      }else{
        i <- i
      }
    }
  }
}
x_zero

```

# Exercício 4
<p>Para um número baixo de simulações, a convergência não é adequada.</p>
```{r,message=FALSE,warning=FALSE}
densidade <- function(x){
  if((all(x) >= 0) && (all(x <= 1/3))){
    return(((3^30) - 1)/2)
  }else{
    return(1)
  }
}

probtransicao <- function(i){
  p <- sample(c("a","b","c"), size = 1)
  if(i == 100 && (p == "b"))
    return(i)
  if(i == 100 && !(p == "b"))
    return(i - 1)
  if(i != 100 && (p == "a"))
    return(i + 1)
  if(i != 100 && (p == "b"))
    return(i)
  if(i != 100 && (p == "c"))
    return(i - 1)
}

t_function <- function(t){
  return((t+1)^2)
}

d <- 30
NSim <- 100
x0 <- runif(d,0,1)
x <- matrix(NA, nrow = NSim, ncol = 30)
x[NSim,] <- x0
i <- 100
while(i >= 1){
  y <- runif(n = d, min = 0, max = 1)
  alpha <- min(1, densidade(y)/densidade(x[i,]))
  x_i_prop <- x[i,] + (y-x[i,])*(runif(1) < alpha)
  j <- probtransicao(i)
  if(j == i){
    x[i-1,] <- x_i_prop
    i <- i - 1
  }else{
    r <- min(1, exp(-log(1/densidade(y))*((1/t_function(j))-(1/t_function(i)))))
    if(rbinom(1,1,r) == 1){
      x[i-1,] <- x_i_prop
      i <- j
    }else{
      i <- i
    }
  }
}
hist(x,prob=T,main="",ylab="Densidade")
```

# Exercício 5
```{r}
# n = número de pontos procurados
# f = distribuição procurada
# x.interval is the A,B range of x values possible.
sliceSample = function (n, f, x.interval = c(0, 1), root.accuracy = 0.01) {
  pts = vector("numeric", n)  # Vetor para receber os pontos
  x = runif(1, x.interval[1], x.interval[2]) # Valor inicial de x
  for (i in 1:n) {
    pts[i] = x
    y = runif(1, 0, f(x))    # Seleciona y aleatório
    detectardif = function (x){ # Detectar diferenças entre valores e a raiz
      f(x) - y 
    }
    roots = c()
    # De cada raiz, seleciona-se o ponto médio 
    # Verificando se está abaixo da curva (validando o segmento)
    for (j in seq(x.interval[1], x.interval[2] - root.accuracy, by = root.accuracy)) {
      if ((detectardif(j) < 0) != (detectardif(j + root.accuracy) < 0)) {
        root = uniroot(detectardif, c(j, j + root.accuracy))$root
        roots = c(roots, root)
      }
    }
    roots = c(x.interval[1], roots, x.interval[2]) #Inclui os pontos extremos ao intervalo
    segments = matrix(ncol = 2) #Divide as interseções em segmentos de linhas
    for (j in 1:(length(roots) - 1)) {
      midpoint = (roots[j + 1] + roots[j]) / 2.0
      if (f(midpoint) > y) {
        segments = rbind(segments, c(roots[j], roots[j + 1]))
      }
    }
    # Amostra o próximo x uniformemente dentre os segmentos 
    total = sum(sapply(2:nrow(segments), function (i) {segments[i, 2] - segments[i, 1]}))
    # Atribui probabilidades de escolha a cada segmento
    probs = sapply(2:nrow(segments), function (i) {(segments[i, 2] - segments[i, 1]) / total})
    p = runif(1, 0, 1)
    selectSegment = function (x, i) { # Função para selecionar o segmento de linha
      if (p < x) return(i)
      else return(selectSegment(x + probs[i + 1], i + 1))
    }
    seg = selectSegment(probs[1], 1) # Seleciona o segmento de linha
    x = runif(1, segments[seg + 1, 1], segments[seg + 1, 2]) # Amostra o novo valor de x
  }
  return(pts)
}
densidade = function (x) { 
  (1/3)*dnorm(x, -5, 1)+(2/3)*dnorm(x, 5, 1)
}
pontos = sliceSample(n = 10000, densidade, x.interval=c(0, 20), root.accuracy = 0.1)
curve(((1/3)*dnorm(x, -5, 1))+((2/3)*dnorm(x, 5, 1)), from = -20, to = 20, ylab="Densidade", main="Slice Sampling",ylim=c(0,0.5))
lines(density(pontos), col="red")
legend("topleft",legend = c("Real","Estimado"),col=c("black","red"),lty=1,box.lty=0,cex=0.7)
```

# Exercício 6
<p>Não obtive êxito na busca ou construção dos algoritmo Swendsen-Wang e Wolff. Há funções de pacotes no R que realizam estes algoritmos, como por exemplo:</p>
```{r,message=F,warning=F}
# install.packages("bayesImageS")
# require(bayesImageS)
# neigh <- matrix(c(5,2,5,3,  1,5,5,4,  5,4,1,5,  3,5,2,5), nrow=4, ncol=4, byrow=TRUE)
# blocks <- list(c(1,4), c(2,3))
# res.sw <- swNoData(0.7, 3, neigh, blocks, niter=200)
# res.sw$z
# res.sw$sum[200]
# swNoData
# getAnywhere(swNoData)
```
